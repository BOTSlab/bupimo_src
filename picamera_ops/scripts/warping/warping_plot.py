#!/usr/bin/env python
"""
Creates a plot of home vectors generated by the 'warping' module.
"""

import matplotlib
#matplotlib.use('GTKAgg')

import matplotlib.pyplot as plt
import scipy as sp
import scipy.signal
import numpy as np
import math, random, warping

width = 50
height = 50
delta = 5

image_width = 20

angle_delta = 2*math.pi/image_width

# Initialize arena to grey (value 0.5)
arena = 0.5 * sp.ones([height, width])

def prob_boundary():
    # The length of the perimeter (double counts corners)
    n_perim = 2*width + 2*height

    #key = [1, 1, 0, 0, 0, 1, 0, 1, 0, 0]
    #key = random.sample(xrange(1), 50)
    #key = [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]
    #sequence = sp.signal.resample(key, n_perim)

    key = []
    for i in range(n_perim/10):
        key.append(random.randint(0,1))

    print key
    sequence = np.repeat(key, n_perim/len(key))
    print sequence

    # Go in sequence around the boundary 
    i = 0
    for y in range(height):
        arena[y, 0] = sequence[i]
        i += 1
    for x in range(width):
        arena[height-1, x] = sequence[i]
        i += 1
    for y in range(height-1, 0, -1):
        arena[y, width-1] = sequence[i]
        i += 1
    for x in range(width-1, 0, -1):
        arena[0, x] = sequence[i]
        i += 1

def simple_boundary():
    # Set left wall to black
    for y in range(height):
        arena[y, 0] = 0

    # Set right wall to white
    for y in range(height):
        arena[y, width-1] = 1

    # Set top wall to white
    for x in range(width):
        arena[0, x] = 1

    # Set bottom wall to white
    for x in range(width):
        arena[height-1, x] = 1

def castray(start_x, start_y, angle):
    x = start_x
    y = start_y
    value = arena[y, x]
    while x >= 0 and x < width and y >= 0 and y < height and value == 0.5:
        value = arena[y, x]
        x += math.cos(angle)
        y += math.sin(angle)

    return value

def raytrace_image(x, y):
    angle = 0
    pixels = []
    while angle < 2*math.pi:
        pixels.append(float(castray(x, y, angle)))
        angle = angle + angle_delta
    return pixels

def compute_home_vector(axes, cx, cy):
    cv = raytrace_image(cx, cy)
    warping.compute_home_vector(0, cv)
    hx = warping.get_home_x()
    hy = warping.get_home_y()

    l = math.sqrt(hx*hx + hy*hy)
    if l > 0.001:
        hx /= l
        hy /= l
        axes.arrow(cx, cy, hx, hy, fc="k", ec="k", head_width=0.4, head_length=0.2)

def plot_for_sx_sy(axes, sx, sy):
    print "sx, sy: " + str(sx) + ", " + str(sy)

    ss = raytrace_image(sx, sy)
    warping.set_snapshot(0, ss)
    
    axes.imshow(arena, cmap='Greys')
    axes.hold(True)
    for cx in range(delta, width, delta):
        for cy in range(delta, height, delta):
            compute_home_vector(axes, cx, cy)
    plt.draw()

if __name__ == '__main__':

    # simple_boundary()
    prob_boundary()

    warping.init(1)

    f, axarray = plt.subplots(2, 2)
    plot_for_sx_sy(axarray[0, 0], 5, 5)
    plot_for_sx_sy(axarray[1, 0], 25, 25)
    plot_for_sx_sy(axarray[0, 1], 45, 5)
    plot_for_sx_sy(axarray[1, 1], 45, 45)
    plt.show()
